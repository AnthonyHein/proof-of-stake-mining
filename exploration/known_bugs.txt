- If the exploration depth is x. Then for states with sequence length x, the explorer will not
bound this state with any ActionBound. It will only use LemmaLowerBound or LemmaUpperBound. This
is because taking an action and looking at subsequent states would exceed the exploration depth.

- Cannot use "promised" actions (like selfish mining) as lower bounds.

- state_utils.occurs_after_state() only promises to work correctly on states where the attacker
has not yet published anything. This is because it is very difficult to know _when_ blocks in the
longest path were added to the longest path and so it is difficult to know if a state occurs after
another in the general case.

- At the exploration depth, the explorer will not look at the action "Wait" since the subsequent
states exceed the exploration depth. In turn, the resulting bounds are inaccurate since the loosest
upper bound is usually due to waiting. To fix this, at the exploration depth the explorer does not
try out _any_ actions.

- Bounds like (A) are incomparable. I am getting a result that waiting yields a larger bound than
Lemma G.8 for a strength of alpha <= 0.3176 though I cannot explain this result and it is a lot
to chase down.

- This code does not terminate for some expressions when trying to compare bounds:

    domain = sp.Interval(settings["alpha_pos_lower_bound"], settings["alpha_pos_upper_bound"])
    # Comparison.
    try:
        soln = sp.solveset(expr_a <= expr_b, alpha, domain)
    except:
        soln = sp.Interval(settings["alpha_pos_lower_bound"], (settings["alpha_pos_lower_bound"] + settings["alpha_pos_upper_bound"]) / 2)

    if soln == domain:
        return True

    elif soln == sp.S.EmptySet:
        return False

    else:

- The code for commitments in `state_utils.py` seems rather fragile. Although not immediately obvious,
there is probably a better way to write it.

- Not sure how to define deficits and runs other than using the code found in `get_deficits_and_runs()`.
As the comment to this function suggests, 